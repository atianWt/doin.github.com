# 代码规范

## 1.	源代码文件
### 1.1	文件命名
* 以本文件中最顶级class名加上.java后缀命名，且大小写敏感 。一个唯一包名的前缀总是全部小写的ASCII 字母并且是一个顶级域名，通常是com，edu，gov，mil，net，org。包名的后续部分根据不同机构各自内部的命名规范而不尽相同。例如： com.alipay.mobile.quinox.XXX

### 1.2	文件编码
	默认编码格式：UTF-8


## 2.	特殊字符
### 2.1	空行
空行将逻辑相关的代码段分隔开，以提高可读性。     
下列情况应该总是使用空行：
* 一个源文件的两个片段(section)之间；
* 类声明和接口声明之间；
* 两个方法之间；
* 方法内的局部变量和方法的第一条语句之间；
* 一个方法内的两个逻辑段之间，用以提高可读性。
* 通常在变量声明区域之后要用空行分隔，常量声明区域之后要有空行分隔，方法声明之前要有空行分隔

### 2.2	缩进
* 在IDE Eclipse中:
	1. 首先拷贝([点击本链接](http://gitlab.alibaba-inc.com/xudong.jiang/checkstyle_over_svn_commit/blob/master/eclipse/android-formatting.xml)->点击"raw"->新页面中选择"Save as")formatter并存为xml文件，然后在eclipse中选择preferences > Java > Code Style > formatter, 然后点击导入，选中下载的formatter文件
	2. 然后拷贝([点击本链接](http://gitlab.alibaba-inc.com/xudong.jiang/checkstyle_over_svn_commit/blob/master/eclipse/android.importorder)->点击"raw"->新页面中选择"Save as")importorder并存为importorder扩展名的文件，然后在eclipse中选择Java > Code Style > Organize Import，然后点击导入，选中下载的importorder文件
	3. (可选)在开发时为了更容易注意到超出列数限制的代码行，可打开"print margin"开关
* 在IDE android studio中：
	1. 将配置文件([点击下载](http://gitlab.alibaba-inc.com/xudong.jiang/checkstyle_over_svn_commit/tree/master/intellij))放置（保持目录结构）到本地windows机器C:\Users\{your_user_name}\.AndroidStudioBeta\config下，mac os机器~/Library/Preferences/AndroidStudioBeta下


## 3. 文件组织
* 一般，一份源代码文件按照如下结构组织：
	* 授权、版权信息，如果有；
	* 包声明；
	* 导入声明；
	* 只包含一个顶级类。
* 并以一个空白行分隔以上每部分。

### 3.1 包声明
	包声明不要进行行截断，每行最多120列的限制不会施加于包声明。
### 3.2 导入声明
* 导入声明不要进行行截断，每行最多120列的限制不会施加于导入声明；
导入声明按以下规则分组：
	*	所有static导入为一组；
	*	第三方的，按照顶级包的字母序排列，例如：android, com, junit, org, sun，java，javax打头的；
	*	组内按照字母序排序；
	*	不要使用通配符式导入，而是使用完全限定名称的类；

**推荐：**

```
import foo.Bar;//（优点是显式制定了特定的类）；  
```

**不推荐：**

```
	import foo.*;//（优点是少写import声明，但是可读性差，且给维护者带来了代价）。
```
### 3.3 类声明
#### 3.3.1 每份源代码有且仅有一个顶级类
#### 3.3.2 成员函数的排列顺序
	一般应该按照逻辑集中的规则来排列（例如操作同一数据的方法尽量放在一起），而不要是新近添加的方法总是放在最后，重载的多个函数应该连续排列。

## 4. 格式
	术语：块级结构指：类、方法、构造方法体（若数组以语句块的形式初始化，也视为块级结构）。

### 4.1 大括号
	大括号应该与if, else, for, do, while语句一起使用，即便其内容为空或只包含单行语句。
#### 4.1.1 确保块级结构内容非空  
**例如**:

```
          return new MyClass() {
              @Override public void method() {
                if (condition()) {
                  try {
                    something();
                  } catch (ProblemException e) {
                    recover();
                  }
                }
              }
            };

```

#### 4.1.2 空白块级结构使用场景
	方法体为空，或空的构造方法
**例如**

```
    void doNothing() {}

    class EmptyConstruct {
        public EmptyConstruct() {}
    }

```

### 4.2 块级缩进  
	4个空白字符（包含代码和注释）,IDE的代码模板已经配好
### 4.3 一条语句占一行
	设置代码风格格式化后，系统会自动进行分行。

### 4.4 列数限制
	任何行超出100列长度的应该进行断行
例外：

1.	没法遵循以上限制，比如JavaDoc中很长的URL，或一个很长的JSNI方法引用；
2.	包声明，导入声明；
3.	可以被直接拷贝粘贴到shell中的命令。

### 4.5 断行
	术语：断行指本可以合法占用一整行，为了不要超过列数限制而进行的将一整行断为多行。

#### 4.5.1 在何处进行断行
	一个原则：尽可能选择在更高的句法级别上进断行，且：  
1. 若遇到非赋值操作符，则在该符号前截断。这条规则同样适用于点操作符的，类型组合符（<T extends Foo & Bar>），catch块中的管道线（catch (FooException | BarException e)）；
2. 若遇到赋值操作符，则在该符号后截断。这条规则同样适用于类赋值操作符（foreach 语句中的:），例如：

```
	IAccessibilityServiceConnection connection =
                AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);

            IAccessibilityServiceConnection connection = AccessibilityInteractionClient
                    .getInstance().getConnection(mConnectionId);

```

3. 方法名或构造方法名与跟随其后的开括号保持连续；
4. .紧跟它之前的符号。

#### 4.5.2 缩进后续行
	截断后的后续行（即不包含第一行）相对原始行最低缩进4个（建议8个）空白字符，多个后续行的情形下，若他们属于同一层的句法元素，则应保持相同的缩进级别。

### 4.6 空白字符
#### 4.6.1 水平对齐
````
	private int x; // this is fine  
	private Color color; // this too  
	private int   x;      // permitted, but future edits  
	private Color color;  // may leave it unaligned  
	//（不作强制要求，不推荐）
````
### 4.7 修饰符
	若存在，类和方法的修饰符应该按照以下顺序排列：  
	public protected private abstract static final transient volatile synchronized native strictfp

## 5. 命名
### 5.1 驼峰规则
	如何将英文词汇转换为符合驼峰规则的标识符
           Prose form                Correct              Incorrect
        "XML HTTP request"        XmlHttpRequest        XMLHTTPRequest
        "new customer ID"         newCustomerId        newCustomerID
        "inner stopwatch"          innerStopwatch        innerStopWatch
        "supports IPv6 on iOS?"     supportsIpv6OnIos      supportsIPv6OnIOS
        "YouTube importer"        YouTubeImporter
         YoutubeImporter*


**可接受但不推荐的情形：**

*	"nonempty"和"non-empty"都是合法的英文单词, 所以checkNonempty和checkNonEmpty都可以认为正确。

*	注意：请命名时一定准备一本英文词典在附近，不要出现基本的英文拼写错误，目前已经发现的案例有：  

*	behaviour/behavor, pool/poll, request/reqeust, continue, external等。

### 5.2 类名
* 命名规则：类名是个一名词，采用大小写混合的方式，每个单词的首字母大写。尽量使你的类名简洁而富于描述。使用完整单词，避免缩写词(除非该缩写词被更广泛使用，像 URL，HTML)。
* 类名必须使用驼峰规则（详见5.1），即首字母必须大写，如果为词组，则每个单词的首字母也必须要大写，类名必须使用名词，或名词词组。要求类名简单，不允许出现无意义的单词
* 接口一般要使用able、ible、er 等后缀。

### 5.3 方法名
* 命名规则：方法名是一个动词，采用大小写混合的方式，第一个单词的首字母小写，其后单词的首字母大写，即采用小写打头的驼峰风格，最好以动词，或动宾短语命名。
* 唯一建议使用下划线的地方是在JUnit中用于为多个测试方法进行逻辑分组，一个典型的模式：  
* test<MethodUnderTest>_<state>，比如： testPop_emptyStack
* 缩略词当做单词对待，而不要保持全大写（命名为getUrl, 而不是getURL）。
* 类中常用方法的命名：
	* 	类的获取方法（一般具有返回值）一般要求在被访问的字段名前加上get，如 getFirstName()，getLastName()。一般来说，get前缀方法返回的是单个值，find前缀的方法返回的是列表值。
	* 	类的设置方法（一般返回类型为void）：被访问字段名的前面加上前缀 set，如 setFirstName(),setLastName().
	* 	类的布尔型的判断方法一般要求方法名使用单词 is或has 做前缀，如isPersistent()，isString()。或者使用具有逻辑意义的单词，例如equal 或equals。
	* 	类的普通方法一般采用完整的英文描述说明成员方法功能，第一个单词尽可能采用动词，首字母小写，如openFile（），addCount（）。
	* 	构造方法应该用递增的方式写。（参数多的写在后面）。

### 5.4 常量变量命名
* 命名规则：第一个单词的首字母小写，其后单词的首字母大写。变量名不应以下划线或美元（$）符号开头，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。临时变量通常被取名为 i，j，k，m 和 n，它们一般用于整型；c，d，e，它们一般用于字符型。变量命名也必须使用驼峰规则（详见5.1），但是首字母必须小写，变量名尽可能的使用名词或名词词组。同样要求简单易懂，不允许出现无意义的单词。成员变量命名同变量命名，但不要在私有变量前添加m字样！类常量的声明，应该全部大写，单词间用下划线隔开。

**例如：**

```
       // Constants
        static final int NUMBER = 5;
        static final ImmutableList<String> NAMES = ImmutableList.of("Ed", "Ann");
        static final Joiner COMMA_JOINER = Joiner.on(',');  // because Joiner is immutable
        static final SomeMutableType[] EMPTY_ARRAY = {};
        enum SomeEnum { ENUM_CONSTANT }

        // Not constants
        static String nonFinal = "non-final";
        final String nonStatic = "non-static";
        static final Set<String> mutableCollection = new HashSet<String>();
        static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable);
        static final Logger logger = Logger.getLogger(MyClass.getName());
        static final String[] nonEmptyArray = {"these", "can", "change"};

```

### 5.5 异常命名
	自定义异常的命名必须以Exception为结尾。已明确标示为一个异常。

### 5.6 layout id资源命名
* layout xml 的命名必须以 全部单词小写，单词间以下划线分割，并且使用名词或名词词组，即使用 模块名_功能名称 来命名。
* layout 中所使用的id必须以全部单词小写，单词间以下划线分割，并且使用名词或名词词组，并且要求能够通过id直接理解当前组件要实现的功能。
* layout中所使用的所有资源（如drawable,style等）命名必须以全部单词小写，单词间以下划线分割，并且尽可能的使用名词或名词组，即使用 模块名_用途 来命名。如果为公共资源，如分割线等，则直接用用途来命名。

## 6. 编程实践
## 6.1 尽量使用@Override
* 使用@Override(不管是扩展重写方法还是实现接口)来避免直到运行时才可以发现的错误，例如以下打字错误只有在运行时才能发现：

```
    public void onCreate(Bundle savedInstanceState) {

    }

```
而采用以下写法错误在编译时就能被发现

```
    @Override
    public void onCreate(Bundle savedInstanceState) {

    }

```

### 6.2 不要完全忽略异常，尽管这非常诱人  

```
    try {
      int i = Integer.parseInt(response);
      return handleNumericResponse(i);
    } catch (NumberFormatException ok) {
      // it's not numeric; that's fine, just continue
    }
    return handleTextResponse(response);

```
*   绝对不要这么做。也许你会认为：
*    你的代码永远不会碰到这种出错的情况，或者处理异常并不重要，
*    可类似上述忽略异常的代码将会在代码中埋下一颗地雷，说不定哪天它就会炸到某个人了。
*    你必须在代码中以某种规矩来处理所有的异常。根据情况的不同，处理的方式也会不一样。
*    "无论何时，空的catch语句都会让人感到不寒而栗。
*    虽然很多情况下确实是一切正常，但至少你不得不去忧虑它。在Java中你无法逃离这种恐惧感。"
-James Gosling

**可接受的替代方案包括（按照推荐顺序）：**

* 向方法的调用者抛出异常

```
    void setServerPort(String value) throws NumberFormatException {
        serverPort = Integer.parseInt(value);
    }
```
* 根据抽象级别抛出新的异常：

```
     void setServerPort(String value) throws ConfigurationException {
        try {
            serverPort = Integer.parseInt(value);
        } catch (NumberFormatException e) {
            throw new ConfigurationException("Port " + value + " is not valid.");
        }
    }
```
* 默默地处理错误并在catch {}语句块中替换为合适的值：

```
    void setServerPort(String value) {
        try {
            serverPort = Integer.parseInt(value);
        } catch (NumberFormatException e) {
            serverPort = 80;  // default port for server
        }
    }

```

* 捕获异常并抛出一个新的RuntimeException。这种做法比较危险：只有确信发生该错误时最合适的做法就是崩溃，才会这么做：

```
     void setServerPort(String value) {
        try {
            serverPort = Integer.parseInt(value);
        } catch (NumberFormatException e) {
            throw new RuntimeException(
"port " + value " is invalid, ", e);
        }
    }

```

* 如果确信忽略异常比较合适，那就忽略吧，但必须把合理的原因注释出来：

```
    void setServerPort(String value) {
        try {
            serverPort = Integer.parseInt(value);
        } catch (NumberFormatException e) {
            // Method is documented to just ignore invalid user input.
            // serverPort will just be unchanged.
        }
    }

```
例外：在测试用例中一个期望发生的异常

```
    try {
        emptyStack.pop();
        fail();
    } catch (NoSuchElementException expected) {
    }
```

### 6.3 不要偷懒而去捕获顶级Exception

```
try {
       和 someComplicatedIOFunction();        // may throw IOException
        someComplicatedParsingFunction();   // may throw ParsingException
        someComplicatedSecurityFunction();  // may throw SecurityException
                                            // phew, made it all the way
    } catch (Exception e) {                 // I'll just catch all exceptions
        handleError();                      // with one generic handler!
    }

```
* 要这么做。绝大部分情况下，捕获顶级的Exception或Throwable都是不合适的，Throwable更不合适，因为它还包含了Error异常。这种捕获非常危险。
*     这意味着本来不必考虑的Exception（包括类似ClassCastException的RuntimeException）被卷入到应用程序级的错误处理中来。
*     这会让代码运行的错误变得模糊不清。这意味着，假如别人在你调用的代码中加入了新的异常，编译器将无法帮助你识别出各种不同的错误类型。
*     绝大部分情况下，无论如何你都不应该用同一种方式来处理各种不同类型的异常。

**当你执意想这样做：**

*     在开始之前，你应该非常仔细地考虑一下，并在注释中解释清楚为什么这么做是安全的。
*     比捕获顶级Exception更好的方案：
*     分开捕获每一种异常，在一条try语句后面跟随多个catch语句块。
*     这样可能会有点别扭，但总比捕获所有Exception要好些。请小心别在catch语句块中重复执行大量的代码。
*     重新组织一下代码，使用多个try块，使错误处理的粒度更细一些。把IO从解析内容的代码中分离出来，根据各自的情况进行单独的错误处理。
*     再次抛出异常。很多时候在你这个级别根本就没必要捕获这个异常，只要让方法抛出该异常即可。
*    请建立一个观点：异常是你的朋友！当编译器指出你没有捕获某个异常时，请不要皱眉头。而应该微笑：编译器帮助你找到了代码中的运行时（runtime）问题。


### 6.4 静态成员：通过类名来限定

```
    Foo aFoo = ...;
    Foo.aStaticMethod(); // good
    aFoo.aStaticMethod(); // bad

```

### 6.5 永远不要重载finalize方法
* 除非：你需要在JNI方法中在Java对象被GC回收时释放native层资源。

### 6.6 尽量限制变量的作用域

```
    // GOOD
    if (…) {
        double d = someCalculation(…);
        doSomethingWith(d);
    } else {
        // No use of d
    }
    // BAD
    double d = 0;
    if (…) { … } else { … }

```

### 6.7 为临时性/不完美代码使用TODO注释  
* TODO注释的格式为：

```
 // TODO: {your_comments_here}
```

### 6.8 类和方法前的概述段
* 名词或动词短语，而不要是一整句话，比如：

```
// BAD
A {@code Foo} is a...
// BAD too
This method returns...
// 也不要是一个祈使句：  
Save the record..
```
* 然而需要注意的是：概述段需要想完整的一句话一样打头字母大写，添加合适的标点等等。

### 6.9 类和方法必须包含Javadoc注释
* 注释至少要包含描述该类或方法用途的语句。并且该语句应该用第三人称的动词形式来开头。

### 6.10	 组织方法的原则
*	简短。对方法的代码长度并没有硬性的限制，但通常如果方法代码超过了40行，就该考虑是否可以在不损害程序结构的前提下进行分拆；
*	专注于完成单一功能；
*	可重用；
*	易于测试。

## 7. 操作规范
### 7.1模板及格式化
* 支付宝的开发人员必须保证代码格式化的一致性，否则可能会导致代码冲突， 轻微的耗费人力合并代码；严重时可能导致代码丢失，引起 bug 或者故障。
	*	开发人员必须配置 ALIPAY 的 codetemplates.xml 代码模板文件；
	*	开发人员必须配置 ALIPAY 的 AlipayFormatter.xml 代码格式化文件；
	*	每次提交代码之前，必须对 java 代码 format。

### 7.2代码提交
*	为防止冲突，任何时候，代码（及配置文件）提交前，先从 SVN 中更新 代码和配置文件，以及早发现不兼容的代码变更和冲突；
*	提交代码（及配置文件）时，如果发生冲突时，先看历史说明，再找相 关人员确认，坚决不允许强制覆盖；
*	每次提交代码之前，必须检查是否有 eclipse warning，并 FIX 所有 的 warning（由 dalgen 等自动生成、不允许人工修改的代码例外）；
*	开发过程定期使用 PMD 扫描代码，合并代码时不允许出现 1 级和 2 级的 问题。

### 7.3垃圾清理
* 对于从来没有用到的或者被注释的方法，变量，类，配置文件，动态配置属性等要坚决从系统中清理出去，避免造成过多垃圾。

## 8. 日志规范
1.	打印日志使用框架提供的TraceLogger，不允许使用android系统的android.util.Log以及java中的System.print和exception.printstacktrace等方法。文档：LoggerFactory文档
2.	打印日志时设置合适的日志级别，调用不同的方法，也便于后期排查问题时过滤分析日志。
TraceLogger中几种不同的级别
info verbose debug warn error
按照android官方文档，对几种不同不同的级别是这样区分的，可供参考
(1)Verbose: 开发调试过程中一些详细信息
(2)Debug: 用于调试的信息，编译进产品，但可以在运行时关闭。
(3)Info:例如一些运行时的状态信息，这些状态信息在出现问题的时候能提供帮助。
(4)Warn：警告系统出现了异常，即将出现错误。
(5)Error：系统已经出现了错误。
3.	Log的tag命名，使用Activity名称或者类、模块的名称，能够区分出log所属类或者模块，不要出现自己的姓名拼音或其他简称，使用前最好搜索下钱包中是否有重名tag。
4.	Log内容不要出现无意义的内容，如连续的等号或星号或连续的数字等，要能够准确地表达含义，便于自己及其他开发人员理解
5.	打印Log的地方要能够准确地反映程序逻辑及异常分支，能够从日志中反推用户的操作或程序的工作流。例如如下几种场景打log是非常必要的
	- a)	继承自ActivityApplication的类的生命周期函数中，如onCreate, onStart等，并将传进来的bundle中的 必要参数打印出来
	- b)	activity或fragment的生命周期函数中
	- c)	BroadcastReceiver的onReceive函数入口，通过pipeline启动的runnable的入口
	- d)	Service的方法入口处打印出所传参数及出口出打印出返回值
	- e)	跨bundle调用的方法入口及返回处
	- f)	发生异常时的异常分支处，如try catch里捕获异常时打印出异常
	- g)	对数据库或本地文件进行的增删改查
	- h)	网络操作如下载或rpc的发起及结束时

### 8.1日志输出
*	Release代码禁止以System及Throwable.printStackTrace的方式输出日志信息，必须用 Logger 替代；
*	对 trace/debug/info 级别的日志输出，必须使用条件输出形式，否则大量的日志会增加来自对象 toString 的性能成本；
*	对于日志的打印，任何情况下都不允许日志错误导致业务失败；
*	对于异常堆栈的输出，必须以 log.XXX (“msg”,e)的形式输出，禁止 log.XXX (“msg”+e)的错误形式；
*	支付宝钱包中的标准Log输出要用LoggerFactory.getTraceLogger()、LoggerFactory.getBehavorLogger()、LoggerFactory.getMonitorLogger()形式；
*	最终提交代码前，将代码的调试Log.xxx全部去掉。

### 8.2 错误日志
*	目前线上所有的错误日志都会有埋点自动生成报告，限期安排人员分析解决。
*	对于由于系统原因或者非系统原因造成业务处理失败的事件，都需要用LoggerFactory记录错误日志。

## 9. 注释规范
### 9.1 基本原则

*	对于一个完整的类，应该包括 ALIPAY 的版权注释、类的说明注释、类 成员变量注释，以及 public、protected、private 方法的注释 （setter、getter、接口的实现方法除外），具体例子可以参考 Money 类。
*	必须保证代码和注释的一致性。
*	正确区分使用文档注释和实现逻辑注释

### 9.2 文件注释
* 所有的源文件都应该在开头有一个注释:版权声明。 如下：

```
/**
 * Alipay.com Inc.
 * Copyright (c) 2004-2015 All Rights Reserved.
 */
```
* eclipse 打开Preferences > Java >Code Style > Code Template，在右边找到Comments > Files 点击右边的Edit ，把下面的代码粘贴过去即可

```
/**
 * Alipay.com Inc.
 * Copyright (c) 2004-${year} All Rights Reserved.
 */
```
* Android Studio 打开设置页 > 搜索Code Templates 在左边 Includes选项卡 新增一个名为 alipay 扩展为java的文件，把下面的代码粘贴过去

```
/**
 * Alipay.com Inc.
 * Copyright (c) 2004-${YEAR} All Rights Reserved.
 */
```
再切换到Templates选项卡，找到Class、Interface、Enum、AnnotationType，在右边的文本框里最前面插入#parse("alipay.java"),如：

```
#parse("alipay.java")
#if (${PACKAGE_NAME} && ${PACKAGE_NAME} != "")package ${PACKAGE_NAME};#end
#parse("File Header.java")
public class ${NAME} {
}

```


### 9.3 类注释
* 每一个类都要包含如下格式的注释，以说明当前类的功能等。  如：

```
/**
 * 类说明注释
 * @author xudong.jiang
 * @version $Id: T.java, v 0.1 2015年9月24日 上午11:36:59 xudong.jiang Exp $
 */
```
* eclipse 打开Preferences > Java >Code Style > Code Template，在右边找到Comments > Types 点击右边的Edit ，把下面的代码粘贴过去即可

```
/**
 *
 * @author ${user}
 * @version $$Id: ${file_name}, v 0.1 ${date} ${time} ${user} Exp $$
 */
```
* Android Studio 打开设置页 > 搜索Code Templates 在左边 Includes选项页 找到File Header的文件，把下面的代码粘贴过去 替换原有内容

```
/**
 *
 * @author ${USER}
 * @version $$Id: ${NAME}.java, v 0.1 ${DATE} ${TIME} ${USER} Exp $$
 */
```


### 9.4 方法注释
* 每一个方法都要包含 如下格式的注释 包括当前方法的用途，当前方法参数的含义，当前方法返回值的内容和抛出异常的列表。  

```
/**   
*     
* 方法的一句话概述    
* <p>方法详述（简单方法可不必详述）</p>   
* @param s 说明参数含义   
* @return 说明返回值含义    
* @throws IOException 说明发生此异常的条件    
* @throws NullPointerException 说明发生此异常的条件    */

```


### 9.5 类成员变量和常量注释
* 成员变量和常量需要使用java doc形式的注释，以说明当前变量或常量的含义

```
/**  
* XXXX含义   */
```

### 9.6 其他注释
* 方法内部的注释 如果需要多行 使用/*„„ */形式，如果为单行是用//„„形式的注释。不要再方法内部使用 java doc 形式的注释“/**„„**/”，简单的区分方法是，java doc形式的注释在 eclipse中为蓝色，普通注释为绿色。

### 9.7 XML注释
* 如果当前layout 或资源需要被多处调用，或为公共使用的layout（若list_item），则需要在xml写明注释。要求注释清晰易懂。


## 10. 安全规范
### 10.1 敏感信息的保护
*用户的敏感信息包括密码、短信验证码、支付验证码、身份证号、银行 卡号、银行密钥，商户密钥等信息；用户敏感信息不能泄露，否则可能 会带来不安全因素。可能会导致敏感信息泄露的方式有:Logger、URL 的 get 参数（因为 URL 的 get 参数会在 apache 日志中被输出）。

### 10.2 WEB 安全
*	对于前台的 web 页面，必须加上表单防重复提交功能；对于业务关键字段需要加上防篡改的功能，否则可能造成业务重复执行或者被客户端恶 意修改。
*	对于前台的 web 页面，严禁出现方便调试的后门页面
*	不允许出现页面向自身重定向、或者多个页面间相互重定向的情况。如 果控制不当，很容易造成系统宕机。

### 11. 通用规范
### 11.1接口变更规范
1.	尽量将接口和实现分离，保证接口稳定性
2.	接口变遵循先增后减原则，旧接口注明Deprecated，由owner推进使用新接口，迁移完成后再将旧接口删除

### 11.2依赖变更规范
1.	依赖变更要慎重，要充分评估影响，并且制定消除影响的方案
2.	底层模块的依赖变更，建议在scm的协助下批量处理
3.	依赖变更的处理，建议放在晚上或者周末进行，避免影响所有人
4.	依赖变更完成后，要邮件通知到有可能影响的模块

### 11.3 金额的使用
* 资金计算处理必须使用 Money 类，禁止使用浮点数（Double，Float 等）直接进行处理，否则会有精度问题。

### 11.4 枚举的使用
* 对于枚举，必须使用 JDK1.5 自带的 Enum，不允许新建阿里枚举，否则可 能会有 Xfire 调用、死锁等问题。
### 11.5 URL 使用
* 外部重定向地址必须使用 URIBroker 生成，否则由于线上采用的是 https 协议，会导致浏览器提示“不安全提示”。
### 11.6 配置信息的使用
* 避免将 UserID、AccountNO、URL、文件名、系统开关参数、业务规则的可变参数等硬编码。
### 11.7 异常处理
* 	捕捉到的异常，不允许不做任何处理就截断，至少要记入日志，或重新 抛出。
* 	最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。
### 11.8 资源的使用
	对系统资源的访问，使用后必须释放系统资源。这类资源包括：文件流、线 程、网络连接、数据库连接等。

* 	对于文件、流的 IO 操作，必须通过 finally 关闭。
* 	对于线程，线程资源必须通过线程池提供，不允许在应用中自行显式创 建线程。
* 	对于网络连接数据库连接，必须由框架通过连接池提供，不允许应用中自行建立网络数据库连接。

### 11.9 本地事务操作
* 	对于业务逻辑上不允许并发访问的数据（例如具有全局唯一性的数据， 涉及到总和类的数据等），必须采用事务和加锁的方式进行处理。
* 	对于业务逻辑上要求数据完整性的数据（例如同时操作多个表，对同一 个表反复进行操作等），必须采用事务的方式进行处理。

### 11.10 线程安全处理
	虽然容器会负责多线程的处理，但是程序中还是会遇到很多线程安全的问题， 开发人员必须注意并发处理，否则可能导致死锁或者资损。
* 	线程上下文变量的设置不清除必须配对。
* 	静态 Util 或单例必须是线程安全的。
* 	DateFormat 类是非线程安全的，类变量使用时会被破坏。每次使用都要重新构造，或者使用 DateUtil 工具类。
* 	为记录加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。
